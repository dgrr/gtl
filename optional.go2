package gtl

// Optional defines an optional object.
type Optional[T any] struct {
	v *T
}

func NewOptional[T any](v *T) Optional[T] {
	return Optional[T]{
		v: v,
	}
}

func OptionalFrom[T any](v T, err error) (opt Optional[T]) {
	return opt.From(v, err)
}

func (opt Optional[T]) From(v T, err error) Optional[T] {
	if err == nil {
		opt.v = &v
	}

	return opt
}

// V returns the held value if it has been defined previously.
func (opt Optional[T]) V() (v T) {
	if opt.v != nil {
		v = *opt.v
	}

	return
}

// Or assigns `v` to `opt` only if the Optional value is not defined.
func (opt Optional[T]) Or(v T) Optional[T] {
	if opt.v == nil {
		opt.v = &v
	}

	return opt
}

// Ok returns true if Optional is holding a value.
func (opt Optional[T]) Ok() bool {
	return opt.v != nil
}

// Set sets the value to the optional struct.
func (opt *Optional[T]) Set(v T) {
	opt.v = &v
}

// Drop drops any previously set value.
func (opt *Optional[T]) Drop() {
	opt.v = nil
}
