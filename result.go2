package gtl

// Result represents the result of a function.
//
// A result has an expected value, which is T
// and an unexpected value, which is E. E is often used as error.
type Result[T, E any] struct {
	v T
	e Optional[E]
}

// ResultFrom returns a Result from 2 values. It is useful when we want
// to capture old-style function returning.
func ResultFrom[T any](v T, err error) (r Result[T, error]) {
	r.v = v
	if err != nil {
		r.e.Set(err)
	}

	return r
}

// Ok returns a Result holding an expected value.
//
// If `r` was previously holding an unexpected value that is discarded.
func (r Result[T, E]) Ok(v T) Result[T, E] {
	r.v = v
	r.e.Drop()

	return r
}

// Err returns a Result holding an unexpected value (an error).
func (r Result[T, E]) Err(e E) Result[T, E] {
	r.e.Set(e)

	return r
}

// Or sets the value `v` only if the error was previously set.
// That means: In case the Result has failed, set this alternative value.
//
// If the Result is holding an error, the error is cleared out and `v` is set.
func (r Result[T, E]) Or(v T) Result[T, E] {
	if r.e.Has() {
		r = r.Ok(v)
	}

	return r
}

// V returns the expected value.
func (r Result[T, E]) V() T {
	return r.v
}

// Err returns the unexpected value.
func (r Result[T, E]) E() E {
	return r.e.V()
}

// VE returns V and E.
func (r Result[T, E]) VE() (T, E) {
	return r.V(), r.E()
}

// Then is executed if Result is not holding an unexpected error.
func (r Result[T, E]) Then(fn func(T)) Result[T, E] {
	if !r.e.Has() {
		fn(r.v)
	}

	return r
}

// Else is executed if Result is holding an unexpected error.
func (r Result[T, E]) Else(fn func(E)) Result[T, E] {
	if r.e.Has() {
		fn(r.e.V())
	}

	return r
}
