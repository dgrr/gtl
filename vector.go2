package gtl

// Vec represents a slice of type `T`.
type Vec[T any] []T

// NewVec returns a new Vec.
//
// If `elmnts` is defined, the contents will be append.
func NewVec[T any](elmnts ...T) Vec[T] {
	vc := Vec[T]{}
	vc.Append(elmnts...)

	return vc
}

// Resize ensures `vc` has at least len = n.
func (vc *Vec[T]) Resize(n int) {
	if nSize := n - cap(*vc); nSize > 0 {
		*vc = append((*vc)[:cap(*vc)], make([]T, nSize)...)
	}

	*vc = (*vc)[:n]
}

// Append appends `elmnts` to the end of the vector.
func (vc *Vec[T]) Append(elmnts ...T) {
	*vc = append(*vc, elmnts...)
}

// Push pushes the `elmnts` into the first positions of the vector.
func (vc *Vec[T]) Push(elmnts ...T) {
	*vc = append((*vc)[:len(elmnts)], *vc...)
	copy(*vc, elmnts)
}

// Front returns a pointer to the first element of the vector.
func (vc *Vec[T]) Front() *T {
	return &(*vc)[0]
}

// Back returns a pointer to the last element of the vector.
func (vc *Vec[T]) Back() *T {
	return &(*vc)[vc.Len()-1]
}

// PopBack returns the last element and removes it from the vector.
func (vc *Vec[T]) PopBack() (e T) {
	if len(*vc) > 0 {
		e = (*vc)[len(*vc)-1]
		*vc = (*vc)[:len(*vc)-1]
	}

	return
}

// PopFront returns the first elements and removes it from the vector.
func (vc *Vec[T]) PopFront() (e T) {
	if len(*vc) > 0 {
		e = (*vc)[0]
		*vc = append((*vc)[:0], (*vc)[1:]...)
	}

	return
}

// Len returns the number of elements in `vc`.
func (vc *Vec[T]) Len() int {
	return len(*vc)
}

// Iter returns an iterator over the vector.
func (vc *Vec[T]) Iter() Iterator[T] {
	return vc.iter()
}

func (vc *Vec[T]) iter() *Iter[T, int] {
	it := &Iter[T, int]{
		v: nil,
		next: func(cnt int) (*T, int) {
			if cnt < vc.Len() {
				return &(*vc)[cnt], cnt + 1
			}

			return nil, cnt + 1
		},
		advance: func(cnt, n int) (*T, int) {
			cnt += n
			if cnt < vc.Len() {
				return &(*vc)[cnt], cnt
			}

			return nil, cnt
		},
	}

	return it
}

// Index returns the index of an element inside the vector.
// The `cmpFn` lambda is used to perform the comparison. The lambda
// gets as input an Iterator[T] and should return true if the value matches the expected.
func (vc *Vec[T]) Index(cmpFn func(it Iterator[T]) bool) int {
	i := -1
	for it := vc.iter(); it.Next(); {
		if cmpFn(it) {
			i = it.Index()
			break
		}
	}

	return i
}

// Search is like Search but it returns the Iterator that matched.
func (vc *Vec[T]) Search(cmpFn func(it Iterator[T]) bool) Iterator[T] {
	for it := vc.iter(); it.Next(); {
		if cmpFn(it) {
			return it
		}
	}

	return nil
}