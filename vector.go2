package gtl

// Vec represents a slice of type `T`.
type Vec[T any] []T

// NewVec returns a new Vec.
//
// If `elmnts` is defined, the contents will be append.
func NewVec[T any](elmnts ...T) Vec[T] {
	vc := Vec[T]{}
	vc.Append(elmnts...)

	return vc
}

// Append appends `elmnts` to the end of the vector.
func (vc *Vec[T]) Append(elmnts ...T) {
	*vc = append(*vc, elmnts...)
}

// Push pushes the `elmnts` into the first positions of the vector.
func (vc *Vec[T]) Push(elmnts ...T) {
	*vc = append((*vc)[:len(elmnts)], *vc...)
	copy(*vc, elmnts)
}

// Front returns a pointer to the first element of the vector.
func (vc *Vec[T]) Front() *T {
	return &(*vc)[0]
}

// Back returns a pointer to the last element of the vector.
func (vc *Vec[T]) Back() *T {
	return &(*vc)[vc.Len()-1]
}

// PopBack returns the last element and removes it from the vector.
func (vc *Vec[T]) PopBack() (e T) {
	if len(*vc) > 0 {
		e = (*vc)[len(*vc)-1]
		*vc = (*vc)[:len(*vc)-1]
	}

	return
}

// PopFront returns the first elements and removes it from the vector.
func (vc *Vec[T]) PopFront() (e T) {
	if len(*vc) > 0 {
		e = (*vc)[0]
		*vc = append((*vc)[:0], (*vc)[1:]...)
	}

	return
}

// Len returns the number of elements in `vc`.
func (vc *Vec[T]) Len() int {
	return len(*vc)
}

// Iter returns an iterator over the vector.
func (vc *Vec[T]) Iter() Iterator[T] {
	it := &Iter[T, int]{
		v: nil,
	}
	it.next = func(cnt int) (*T, int) {
		if cnt < vc.Len() {
			return &(*vc)[cnt], cnt+1
		}

		return nil, cnt+1
	}

	return it
}
